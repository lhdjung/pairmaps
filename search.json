[{"path":"https://lhdjung.github.io/pairmaps/LICENSE.html","id":null,"dir":"","previous_headings":"","what":"MIT License","title":"MIT License","text":"Copyright (c) 2022 pairmaps authors Permission hereby granted, free charge, person obtaining copy software associated documentation files (“Software”), deal Software without restriction, including without limitation rights use, copy, modify, merge, publish, distribute, sublicense, /sell copies Software, permit persons Software furnished , subject following conditions: copyright notice permission notice shall included copies substantial portions Software. SOFTWARE PROVIDED “”, WITHOUT WARRANTY KIND, EXPRESS IMPLIED, INCLUDING LIMITED WARRANTIES MERCHANTABILITY, FITNESS PARTICULAR PURPOSE NONINFRINGEMENT. EVENT SHALL AUTHORS COPYRIGHT HOLDERS LIABLE CLAIM, DAMAGES LIABILITY, WHETHER ACTION CONTRACT, TORT OTHERWISE, ARISING , CONNECTION SOFTWARE USE DEALINGS SOFTWARE.","code":""},{"path":"https://lhdjung.github.io/pairmaps/articles/factory-labels.html","id":"balancing-pros-and-cons","dir":"Articles","previous_headings":"","what":"Balancing pros and cons","title":"Adverb, function operator, or function factory?","text":"tend prefer “function factory” ’s formal “adverb” also highly evocative. ’s used context languages well, Python Javascript. term less precise “function operator”, think won’t much harm. Although function operators may use cases factories, differences significant development. also true working factory package, great tool writing new function factories. Yet “adverb” elegant metaphor smoothly conveys functions’ usage. Consider example purrr: Somebody familiar log() function factories likely make sense idea safely() modifies way log() works. might less intuitive safely() takes log input, returns new safe_log function,1 calls function object argument — although exactly happens, function operators general . Accessible explanations needed even acutely rewrite example: syntax — two sets parentheses, seemingly following function — puzzle anybody encounters first time. goes easier explain saying safely() adverb changes way log() works. Note output , two notations equivalent. Referring functions “adverbs”, however, precise. R objects usually can’t modified place (Wickham 2019, ch. 2.3), adverbs don’t actually change input functions. Instead, create return entirely new functions apply input ones particular way. sheer complexity means speaking adverbs modification often reasonable, especially focus using function factories, writing .","code":"safe_log <- purrr::safely(log) safe_log(10) #> $result #> [1] 2.302585 #>  #> $error #> NULL purrr::safely(log)(10) #> $result #> [1] 2.302585 #>  #> $error #> NULL"},{"path":"https://lhdjung.github.io/pairmaps/articles/factory-labels.html","id":"conclusion","dir":"Articles","previous_headings":"","what":"Conclusion","title":"Adverb, function operator, or function factory?","text":"things considered, seems wise developer community speak adverbs user-facing contexts function factories / operators developer-facing contexts. sources linked reference adverbs documentation pages existing functions. contrast, chapters 10-11 Advanced R (Wickham 2019) directed experienced R programmers might want write function factories . applies factory package’s readme. audience need deeper understanding way functions work, concept “function factories” bring sharper view. Advanced R uses term “adverb” , describing function operators introduction relevant chapters: “like adverbs, typically modify operation function.” Isn’t nice segue? Sticking terms advisable case, lest somebody points as_colpair_mapper() actually adverbial phrase.","code":""},{"path":"https://lhdjung.github.io/pairmaps/articles/factory-labels.html","id":"citation-dummy","dir":"Articles","previous_headings":"","what":"Citation dummy","title":"Adverb, function operator, or function factory?","text":"(extra section. display suppressed via CSS element display: none; purpose generate citation Wickham (2019) — want style citation text flexibly format allows (including URL) still get reference pasted bottom.)","code":""},{"path":[]},{"path":"https://lhdjung.github.io/pairmaps/articles/using-pairmaps.html","id":"basics","dir":"Articles","previous_headings":"","what":"Basics","title":"Using pairmaps","text":"main function pairmaps adverb as_colpair_mapper(). modifies given function — “verb” — operates pair columns data frame. precisely, as_colpair_mapper() creates wrapper functions around corrr::colpair_map(). wrapper bound one specific function applies data frame. example: mapped function, f, must take least two arguments (dots, ...). first two column pairs, function must accept vectors . Use as_colpair_mapper() plan reuse resulting function, like max_sum_map(), multiple times. new wrapper function add little value want use . case, directly calling corrr::colpair_map() might better option. Read colpair_map() blogpost. vary() covary() built-examples useful functions made as_colpair_mapper().","code":"max_sum <- function(x, y) {   max(sum(x), sum(y)) } max_sum_map <- as_colpair_mapper(f = max_sum) max_sum_map(mtcars) #> ℹ Applying `max_sum` to each column pair #> # A tibble: 11 × 12 #>    term    mpg   cyl  disp    hp  drat    wt  qsec    vs    am  gear  carb #>    <chr> <dbl> <dbl> <dbl> <dbl> <dbl> <dbl> <dbl> <dbl> <dbl> <dbl> <dbl> #>  1 mpg     NA   643. 7383. 4694   643.  643.  643.  643.  643.  643.  643. #>  2 cyl    643.   NA  7383. 4694   198   198   571.  198   198   198   198  #>  3 disp  7383. 7383.   NA  7383. 7383. 7383. 7383. 7383. 7383. 7383. 7383. #>  4 hp    4694  4694  7383.   NA  4694  4694  4694  4694  4694  4694  4694  #>  5 drat   643.  198  7383. 4694    NA   115.  571.  115.  115.  118   115. #>  6 wt     643.  198  7383. 4694   115.   NA   571.  103.  103.  118   103. #>  7 qsec   643.  571. 7383. 4694   571.  571.   NA   571.  571.  571.  571. #>  8 vs     643.  198  7383. 4694   115.  103.  571.   NA    14   118    90  #>  9 am     643.  198  7383. 4694   115.  103.  571.   14    NA   118    90  #> 10 gear   643.  198  7383. 4694   118   118   571.  118   118    NA   118  #> 11 carb   643.  198  7383. 4694   115.  103.  571.   90    90   118    NA"},{"path":"https://lhdjung.github.io/pairmaps/articles/using-pairmaps.html","id":"more-with-corrr","dir":"Articles","previous_headings":"","what":"More with corrr","title":"Using pairmaps","text":"Running data colpair_map() — directly via wrapper function made as_colpair_mapper() — always return cor_df tibble. cor_df format data frame correlations returned corrr::correlate(), ’s limited computing correlations. Instead, colpair_map() arranges results special format applying user-specified function takes two arguments. enables plug analysis R workflow focused data frames, especially corrr package’s arsenal exploratory functions. Read Using corrr vignette.","code":""},{"path":"https://lhdjung.github.io/pairmaps/articles/using-pairmaps.html","id":"defaults-for-defaults","dir":"Articles","previous_headings":"","what":"Defaults for defaults","title":"Using pairmaps","text":"can control defaults .diagonal .quiet arguments output function specifying default_diagonal default_quiet arguments as_colpair_mapper(): defaults defaults within as_colpair_mapper(), turn, correspond :","code":"max_sum_map <- as_colpair_mapper(   f = max_sum, default_diagonal = 1, default_quiet = TRUE )  # The diagonal is `1`, and no message is displayed! max_sum_map(mtcars) #> # A tibble: 11 × 12 #>    term    mpg   cyl  disp    hp  drat    wt  qsec    vs    am  gear  carb #>    <chr> <dbl> <dbl> <dbl> <dbl> <dbl> <dbl> <dbl> <dbl> <dbl> <dbl> <dbl> #>  1 mpg      1   643. 7383. 4694   643.  643.  643.  643.  643.  643.  643. #>  2 cyl    643.    1  7383. 4694   198   198   571.  198   198   198   198  #>  3 disp  7383. 7383.    1  7383. 7383. 7383. 7383. 7383. 7383. 7383. 7383. #>  4 hp    4694  4694  7383.    1  4694  4694  4694  4694  4694  4694  4694  #>  5 drat   643.  198  7383. 4694     1   115.  571.  115.  115.  118   115. #>  6 wt     643.  198  7383. 4694   115.    1   571.  103.  103.  118   103. #>  7 qsec   643.  571. 7383. 4694   571.  571.    1   571.  571.  571.  571. #>  8 vs     643.  198  7383. 4694   115.  103.  571.    1    14   118    90  #>  9 am     643.  198  7383. 4694   115.  103.  571.   14     1   118    90  #> 10 gear   643.  198  7383. 4694   118   118   571.  118   118     1   118  #> 11 carb   643.  198  7383. 4694   115.  103.  571.   90    90   118     1 max_sum_map <- as_colpair_mapper(   f = max_sum, default_diagonal = NA, default_quiet = FALSE )"},{"path":[]},{"path":"https://lhdjung.github.io/pairmaps/articles/using-pairmaps.html","id":"not-evaluating-too-early","dir":"Articles","previous_headings":"Assignment and copying","what":"Not evaluating too early","title":"Using pairmaps","text":"as_colpair_mapper() one argument, Boolean eval_f. set FALSE, input function appear within output function name . Look .f = max_sum : useful want copy paste printed output script, especially within package. Always set eval_f FALSE call as_colpair_mapper() inside package. (See non-package use cases.) default, eval_f = TRUE, replace name max_sum() function definition — .e., list arguments along entire function body: can imagine might confusing longer functions max_sum(). However, deeper problem still: factory-made function reflect version max_sum() specific point time run as_colpair_mapper(). max_sum() changes later , manually update copied function, even working within package. Otherwise, rely outdated version max_sum()! aren’t developing package copying output as_colpair_mapper() script, manually update anyways run as_colpair_mapper() eval_f = TRUE.","code":"as_colpair_mapper(f = max_sum, eval_f = FALSE) #> function (.data, ..., .diagonal = NA, .quiet = FALSE)  #> { #>     f_name <- \"max_sum\" #>     out <- corrr::colpair_map(.data = .data, .f = max_sum, ...,  #>         .diagonal = .diagonal) #>     if (!.quiet) { #>         rlang::inform(c(i = \"Applying `max_sum` to each column pair\")) #>     } #>     class(out) <- c(paste0(\"pairmaps_df_\", f_name), class(out)) #>     out #> } as_colpair_mapper(f = max_sum) #> function (.data, ..., .diagonal = NA, .quiet = FALSE)  #> { #>     f_name <- \"max_sum\" #>     out <- corrr::colpair_map(.data = .data, .f = function (x,  #>         y)  #>     { #>         max(sum(x), sum(y)) #>     }, ..., .diagonal = .diagonal) #>     if (!.quiet) { #>         rlang::inform(c(i = \"Applying `max_sum` to each column pair\")) #>     } #>     class(out) <- c(paste0(\"pairmaps_df_\", f_name), class(out)) #>     out #> }"},{"path":"https://lhdjung.github.io/pairmaps/articles/using-pairmaps.html","id":"not-evaluating-too-late","dir":"Articles","previous_headings":"Assignment and copying","what":"Not evaluating too late","title":"Using pairmaps","text":"purpose default eval_f = TRUE prevent reverse problem. don’t copy paste output function assign variable straight away, setting eval_f FALSE might lead subtle issue lazy evaluation (Wickham 2019, ch. 10.2.3): happened ? f = max_sum argument evaluated output function, max_sum_map(), ultimately called. , however, value max_sum() changed different function, applied place original max_sum(). made point apparent new max_sum() function returns constant output tibble include many different values. realistic cases, problem might harder spot, safer evaluate f original value max_sum() right as_colpair_mapper() creates max_sum_map(). default eval_f = TRUE provides safety. new value can’t interpreted function, bug doesn’t occur error thrown:","code":"max_sum <- function(x, y) {   max(sum(x), sum(y)) } max_sum_map <- as_colpair_mapper(f = max_sum, eval_f = FALSE) max_sum <- function(...) {   sum1 <- sum(iris$Petal.Width)   sum2 <- sum(mtcars$hp)   sum3 <- sum(sunspots)   max(sum1, sum2, sum3) } max_sum_map(mtcars) #> ℹ Applying `max_sum` to each column pair #> # A tibble: 11 × 12 #>    term     mpg    cyl   disp     hp   drat     wt   qsec     vs     am   gear #>    <chr>  <dbl>  <dbl>  <dbl>  <dbl>  <dbl>  <dbl>  <dbl>  <dbl>  <dbl>  <dbl> #>  1 mpg       NA 144570 144570 144570 144570 144570 144570 144570 144570 144570 #>  2 cyl   144570     NA 144570 144570 144570 144570 144570 144570 144570 144570 #>  3 disp  144570 144570     NA 144570 144570 144570 144570 144570 144570 144570 #>  4 hp    144570 144570 144570     NA 144570 144570 144570 144570 144570 144570 #>  5 drat  144570 144570 144570 144570     NA 144570 144570 144570 144570 144570 #>  6 wt    144570 144570 144570 144570 144570     NA 144570 144570 144570 144570 #>  7 qsec  144570 144570 144570 144570 144570 144570     NA 144570 144570 144570 #>  8 vs    144570 144570 144570 144570 144570 144570 144570     NA 144570 144570 #>  9 am    144570 144570 144570 144570 144570 144570 144570 144570     NA 144570 #> 10 gear  144570 144570 144570 144570 144570 144570 144570 144570 144570     NA #> 11 carb  144570 144570 144570 144570 144570 144570 144570 144570 144570 144570 #> # … with 1 more variable: carb <dbl> max_sum <- function(x, y) {   max(sum(x), sum(y)) } max_sum_map <- as_colpair_mapper(f = max_sum, eval_f = FALSE)  # This new `max_sum` is numeric, not a function: max_sum <- max(sum(iris$Petal.Length, iris$Petal.Width)) max_sum_map(mtcars) #> Error in `map()`: #> ℹ In index: 1. #> ℹ With name: mpg. #> Caused by error in `dplyr::summarise()`: #> ! Problem while computing `..1 = dplyr::across(...)`. #> Caused by error in `across()`: #> ! `.fns` must be NULL, a function, a formula, or a list of #>   functions/formulas."},{"path":"https://lhdjung.github.io/pairmaps/articles/using-pairmaps.html","id":"retrieving-the-mapped-function","dir":"Articles","previous_headings":"","what":"Retrieving the mapped function","title":"Using pairmaps","text":"case pairmaps data frame aren’t sure function applied column pairs, can call get_mapped_function() data frame. Note return function defined moment call get_mapped_function(). means can’t use retrieve earlier functions name. need name mapped function, call get_mapped_function_name() instead: Sometimes, may sure data frame returned function , turn, made as_colpair_mapper(). Test is_pairmaps_df(): get_mapped_function() get_mapped_function_name() internally call is_pairmaps_df() make sure actually deal data frame. test fails, throw error.","code":"max_sum <- function(x, y) {   max(sum(x), sum(y)) } max_sum_map <- as_colpair_mapper(f = max_sum) df <- max_sum_map(mtcars) #> ℹ Applying `max_sum` to each column pair  get_mapped_function(df) #> function(x, y) { #>   max(sum(x), sum(y)) #> } get_mapped_function_name(df) #> [1] \"max_sum\" is_pairmaps_df(df) #> [1] TRUE is_pairmaps_df(iris) #> [1] FALSE"},{"path":"https://lhdjung.github.io/pairmaps/articles/using-pairmaps.html","id":"citation-dummy","dir":"Articles","previous_headings":"","what":"Citation dummy","title":"Using pairmaps","text":"(extra section. display suppressed via CSS element display: none; purpose generate citation Wickham (2019) — want style citation text flexibly format allows (including URL) still get reference pasted bottom.)","code":""},{"path":[]},{"path":"https://lhdjung.github.io/pairmaps/authors.html","id":null,"dir":"","previous_headings":"","what":"Authors","title":"Authors and Citation","text":"Lukas Jung. Author, maintainer.","code":""},{"path":"https://lhdjung.github.io/pairmaps/authors.html","id":"citation","dir":"","previous_headings":"","what":"Citation","title":"Authors and Citation","text":"Jung L (2023). pairmaps: New Column-Pair Mapping Functions. https://github.com/lhdjung/pairmaps, https://lhdjung.github.io/pairmaps/.","code":"@Manual{,   title = {pairmaps: New Column-Pair Mapping Functions},   author = {Lukas Jung},   year = {2023},   note = {https://github.com/lhdjung/pairmaps, https://lhdjung.github.io/pairmaps/}, }"},{"path":"https://lhdjung.github.io/pairmaps/index.html","id":"new-column-pair-mapping-functions","dir":"","previous_headings":"","what":"New column-pair mapping functions","title":"New column-pair mapping functions","text":"pairmaps package provides as_colpair_mapper(), modifies function applied pair columns data frame. Every function created way wrapper around corrr::colpair_map(). can avoid pairmaps dependency copying pasting functions returned as_colpair_mapper() source code. pairmaps unofficial add-corrr. functions don’t dependencies beyond corrr (corrr ).","code":""},{"path":"https://lhdjung.github.io/pairmaps/index.html","id":"installation","dir":"","previous_headings":"","what":"Installation","title":"New column-pair mapping functions","text":"can install development version pairmaps GitHub :","code":"remotes::install_github(\"lhdjung/pairmaps\")"},{"path":"https://lhdjung.github.io/pairmaps/index.html","id":"get-started","dir":"","previous_headings":"","what":"Get started","title":"New column-pair mapping functions","text":"Go vignette(\"using-pairmaps\").","code":""},{"path":"https://lhdjung.github.io/pairmaps/index.html","id":"acknowledgements","dir":"","previous_headings":"","what":"Acknowledgements","title":"New column-pair mapping functions","text":"pairmaps inspired factory.","code":""},{"path":"https://lhdjung.github.io/pairmaps/reference/as_colpair_mapper.html","id":null,"dir":"Reference","previous_headings":"","what":"Adverb for new column-pair mapping functions — as_colpair_mapper","title":"Adverb for new column-pair mapping functions — as_colpair_mapper","text":"as_colpair_mapper() takes function f returns new function applies f pair columns data frame.","code":""},{"path":"https://lhdjung.github.io/pairmaps/reference/as_colpair_mapper.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Adverb for new column-pair mapping functions — as_colpair_mapper","text":"","code":"as_colpair_mapper(   f,   eval_f = TRUE,   class = TRUE,   default_diagonal = NA,   default_quiet = FALSE,   ... )"},{"path":"https://lhdjung.github.io/pairmaps/reference/as_colpair_mapper.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Adverb for new column-pair mapping functions — as_colpair_mapper","text":"f function takes two arguments. eval_f Boolean. set FALSE, f appear output function name rather body arguments. Default TRUE. See details. class Boolean. TRUE (default), data frames returned output function inherit class starts \"pairmaps_df_\", followed name f. default_diagonal, default_quiet Defaults .diagonal .quiet arguments output function. default present function, NA FALSE, respectively. ... dots must empty.","code":""},{"path":"https://lhdjung.github.io/pairmaps/reference/as_colpair_mapper.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Adverb for new column-pair mapping functions — as_colpair_mapper","text":"function. See vary() covary() examples functions made as_colpair_mapper().","code":""},{"path":"https://lhdjung.github.io/pairmaps/reference/as_colpair_mapper.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Adverb for new column-pair mapping functions — as_colpair_mapper","text":"Setting eval_f FALSE can helpful copy paste resulting function script. case, makes sense refer one particular function name, rather copying pasting lengthy function definition within new function definition, manually updating mapped function changes. However, considered value f completely unambiguous, ambiguity might lead subtle bug. See vignette(\"using-pairmaps\"), section Assignment copying.","code":""},{"path":"https://lhdjung.github.io/pairmaps/reference/as_colpair_mapper.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Adverb for new column-pair mapping functions — as_colpair_mapper","text":"Wickham, H. (2019). Advanced R (Second Edition), CRC Press/Taylor Francis Group. https://adv-r.hadley.nz/index.html.","code":""},{"path":[]},{"path":"https://lhdjung.github.io/pairmaps/reference/as_colpair_mapper.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Adverb for new column-pair mapping functions — as_colpair_mapper","text":"","code":"# From `?corrr::colpair_map()` -- a function that # extracts the p-value from a t-test: calc_p_value <- function(vec_a, vec_b) {   stats::t.test(vec_a, vec_b)$p.value }  # Derive a new mapping function: p_value_map <- as_colpair_mapper(f = calc_p_value)  # Below are three near-equivalent calls. # The only difference: In the first two cases, # the output tibble inherits an extra class # that includes the name of `f`. Here, it is # `\"pairmaps_df_calc_p_value\"`.  # 1. Using a ready-made mapping function: p_value_map(.data = mtcars) #> ℹ Applying `calc_p_value` to each column pair #> # A tibble: 11 × 12 #>    term        mpg       cyl      disp        hp      drat        wt      qsec #>    <chr>     <dbl>     <dbl>     <dbl>     <dbl>     <dbl>     <dbl>     <dbl> #>  1 mpg   NA         9.51e-15  7.98e-11  1.03e-11  3.16e-16  1.03e-16  5.11e- 2 #>  2 cyl    9.51e-15 NA         1.77e-11  8.32e-13  2.28e- 9  9.12e-11  3.73e-35 #>  3 disp   7.98e-11  1.77e-11 NA         1.55e- 3  1.35e-11  1.29e-11  6.34e-11 #>  4 hp     1.03e-11  8.32e-13  1.55e- 3 NA         5.28e-13  4.92e-13  7.24e-12 #>  5 drat   3.16e-16  2.28e- 9  1.35e-11  5.28e-13 NA         6.02e- 2  5.91e-33 #>  6 wt     1.03e-16  9.12e-11  1.29e-11  4.92e-13  6.02e- 2 NA         7.27e-39 #>  7 qsec   5.11e- 2  3.73e-35  6.34e-11  7.24e-12  5.91e-33  7.27e-39 NA        #>  8 vs     2.24e-18  3.50e-19  9.62e-12  3.01e-13  2.43e-33  1.33e-18  1.05e-35 #>  9 am     2.15e-18  3.07e-19  9.59e-12  3.00e-13  1.14e-33  9.09e-19  1.13e-35 #> 10 gear   3.08e-16  5.64e- 9  1.36e-11  5.36e-13  5.75e- 1  3.41e- 2  2.97e-35 #> 11 carb   1.68e-17  5.61e-11  1.24e-11  4.55e-13  1.30e- 2  2.31e- 1  1.74e-42 #> # … with 4 more variables: vs <dbl>, am <dbl>, gear <dbl>, carb <dbl>  # 2. Directly working with the adverb: as_colpair_mapper(f = calc_p_value)(.data = mtcars) #> ℹ Applying `calc_p_value` to each column pair #> # A tibble: 11 × 12 #>    term        mpg       cyl      disp        hp      drat        wt      qsec #>    <chr>     <dbl>     <dbl>     <dbl>     <dbl>     <dbl>     <dbl>     <dbl> #>  1 mpg   NA         9.51e-15  7.98e-11  1.03e-11  3.16e-16  1.03e-16  5.11e- 2 #>  2 cyl    9.51e-15 NA         1.77e-11  8.32e-13  2.28e- 9  9.12e-11  3.73e-35 #>  3 disp   7.98e-11  1.77e-11 NA         1.55e- 3  1.35e-11  1.29e-11  6.34e-11 #>  4 hp     1.03e-11  8.32e-13  1.55e- 3 NA         5.28e-13  4.92e-13  7.24e-12 #>  5 drat   3.16e-16  2.28e- 9  1.35e-11  5.28e-13 NA         6.02e- 2  5.91e-33 #>  6 wt     1.03e-16  9.12e-11  1.29e-11  4.92e-13  6.02e- 2 NA         7.27e-39 #>  7 qsec   5.11e- 2  3.73e-35  6.34e-11  7.24e-12  5.91e-33  7.27e-39 NA        #>  8 vs     2.24e-18  3.50e-19  9.62e-12  3.01e-13  2.43e-33  1.33e-18  1.05e-35 #>  9 am     2.15e-18  3.07e-19  9.59e-12  3.00e-13  1.14e-33  9.09e-19  1.13e-35 #> 10 gear   3.08e-16  5.64e- 9  1.36e-11  5.36e-13  5.75e- 1  3.41e- 2  2.97e-35 #> 11 carb   1.68e-17  5.61e-11  1.24e-11  4.55e-13  1.30e- 2  2.31e- 1  1.74e-42 #> # … with 4 more variables: vs <dbl>, am <dbl>, gear <dbl>, carb <dbl>  # 3. Calling the underlying function: corrr::colpair_map(.data = mtcars, .f = calc_p_value) #> # A tibble: 11 × 12 #>    term        mpg       cyl      disp        hp      drat        wt      qsec #>    <chr>     <dbl>     <dbl>     <dbl>     <dbl>     <dbl>     <dbl>     <dbl> #>  1 mpg   NA         9.51e-15  7.98e-11  1.03e-11  3.16e-16  1.03e-16  5.11e- 2 #>  2 cyl    9.51e-15 NA         1.77e-11  8.32e-13  2.28e- 9  9.12e-11  3.73e-35 #>  3 disp   7.98e-11  1.77e-11 NA         1.55e- 3  1.35e-11  1.29e-11  6.34e-11 #>  4 hp     1.03e-11  8.32e-13  1.55e- 3 NA         5.28e-13  4.92e-13  7.24e-12 #>  5 drat   3.16e-16  2.28e- 9  1.35e-11  5.28e-13 NA         6.02e- 2  5.91e-33 #>  6 wt     1.03e-16  9.12e-11  1.29e-11  4.92e-13  6.02e- 2 NA         7.27e-39 #>  7 qsec   5.11e- 2  3.73e-35  6.34e-11  7.24e-12  5.91e-33  7.27e-39 NA        #>  8 vs     2.24e-18  3.50e-19  9.62e-12  3.01e-13  2.43e-33  1.33e-18  1.05e-35 #>  9 am     2.15e-18  3.07e-19  9.59e-12  3.00e-13  1.14e-33  9.09e-19  1.13e-35 #> 10 gear   3.08e-16  5.64e- 9  1.36e-11  5.36e-13  5.75e- 1  3.41e- 2  2.97e-35 #> 11 carb   1.68e-17  5.61e-11  1.24e-11  4.55e-13  1.30e- 2  2.31e- 1  1.74e-42 #> # … with 4 more variables: vs <dbl>, am <dbl>, gear <dbl>, carb <dbl>  # (In the second call, R first evaluates # `as_colpair_mapper(f = calc_p_value)` to a # mapping function just like `p_value_map()`, # and then calls that new function on `mtcars`.)"},{"path":"https://lhdjung.github.io/pairmaps/reference/get_mapped_function.html","id":null,"dir":"Reference","previous_headings":"","what":"Retrieve the function applied to each column pair — get_mapped_function","title":"Retrieve the function applied to each column pair — get_mapped_function","text":"pass function f() as_colpair_mapper(), call resulting function, get data frame back. two functions retrieve f() data frame: get_mapped_function() returns function . get_mapped_function_name() returns function's name string.","code":""},{"path":"https://lhdjung.github.io/pairmaps/reference/get_mapped_function.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Retrieve the function applied to each column pair — get_mapped_function","text":"","code":"get_mapped_function(data)  get_mapped_function_name(data)"},{"path":"https://lhdjung.github.io/pairmaps/reference/get_mapped_function.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Retrieve the function applied to each column pair — get_mapped_function","text":"data Data frame.","code":""},{"path":"https://lhdjung.github.io/pairmaps/reference/get_mapped_function.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Retrieve the function applied to each column pair — get_mapped_function","text":"Function string (length 1).","code":""},{"path":"https://lhdjung.github.io/pairmaps/reference/get_mapped_function.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Retrieve the function applied to each column pair — get_mapped_function","text":"","code":"# `covary()` was made by `as_colpair_mapper()`: df <- covary(mtcars) #> ℹ Applying `stats::cov` to each column pair  # Since `covary()` applies `stats::cov()`, # this is the function returned here: cov_from_df <- get_mapped_function(data = df) identical(cov_from_df, stats::cov) #> [1] TRUE  # Just get the name instead: get_mapped_function_name(data = df) #> [1] \"stats::cov\""},{"path":"https://lhdjung.github.io/pairmaps/reference/is_pairmaps_df.html","id":null,"dir":"Reference","previous_headings":"","what":"Is an object a pairmaps data frame? — is_pairmaps_df","title":"Is an object a pairmaps data frame? — is_pairmaps_df","text":"is_pairmaps_df() tests object data frame returned function made as_colpair_mapper().","code":""},{"path":"https://lhdjung.github.io/pairmaps/reference/is_pairmaps_df.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Is an object a pairmaps data frame? — is_pairmaps_df","text":"","code":"is_pairmaps_df(x)"},{"path":"https://lhdjung.github.io/pairmaps/reference/is_pairmaps_df.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Is an object a pairmaps data frame? — is_pairmaps_df","text":"x object.","code":""},{"path":"https://lhdjung.github.io/pairmaps/reference/is_pairmaps_df.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Is an object a pairmaps data frame? — is_pairmaps_df","text":"single Boolean value.","code":""},{"path":"https://lhdjung.github.io/pairmaps/reference/is_pairmaps_df.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Is an object a pairmaps data frame? — is_pairmaps_df","text":"function checks whether x data frame inherits exactly one S3 class starts \"pairmaps_df_\". given x returned function created as_colpair_mapper() classes manipulated.","code":""},{"path":"https://lhdjung.github.io/pairmaps/reference/is_pairmaps_df.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Is an object a pairmaps data frame? — is_pairmaps_df","text":"","code":"# Basic function, from `?corrr::colpair_map()`: calc_p_value <- function(vec_a, vec_b) {   stats::t.test(vec_a, vec_b)$p.value }  # Produce a new mapper function: p_value_map <- as_colpair_mapper(calc_p_value)  is_pairmaps_df(p_value_map(mtcars)) #> ℹ Applying `calc_p_value` to each column pair #> [1] TRUE  is_pairmaps_df(mtcars) #> [1] FALSE  is_pairmaps_df(4) #> [1] FALSE"},{"path":"https://lhdjung.github.io/pairmaps/reference/vary-covary.html","id":null,"dir":"Reference","previous_headings":"","what":"Variance and covariance data frames — vary-covary","title":"Variance and covariance data frames — vary-covary","text":"vary() covary() return variance covariance data frames instead matrices, making easier explore corrr package.","code":""},{"path":"https://lhdjung.github.io/pairmaps/reference/vary-covary.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Variance and covariance data frames — vary-covary","text":"","code":"vary(.data, ..., .diagonal = NA, .quiet = FALSE)  covary(.data, ..., .diagonal = NA, .quiet = FALSE)"},{"path":"https://lhdjung.github.io/pairmaps/reference/vary-covary.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Variance and covariance data frames — vary-covary","text":".data Numeric vector, matrix data frame. ... arguments passed var() cov(), respectively. .diagonal Value diagonal set. Default NA. .quiet Boolean. Set TRUE suppress message function mapping.","code":""},{"path":"https://lhdjung.github.io/pairmaps/reference/vary-covary.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Variance and covariance data frames — vary-covary","text":"functions return cor_df tibbles, .e., \"correlation data frames\". However, compute correlations: name simply reflects origins cor_df class corrr package.","code":""},{"path":[]},{"path":"https://lhdjung.github.io/pairmaps/reference/vary-covary.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Variance and covariance data frames — vary-covary","text":"","code":"vary(mtcars) #> ℹ Applying `stats::var` to each column pair #> # A tibble: 11 × 12 #>    term      mpg     cyl   disp      hp     drat      wt     qsec       vs #>    <chr>   <dbl>   <dbl>  <dbl>   <dbl>    <dbl>   <dbl>    <dbl>    <dbl> #>  1 mpg     NA     -9.17  -633.  -321.     2.20    -5.12    4.51     2.02   #>  2 cyl     -9.17  NA      200.   102.    -0.668    1.37   -1.89    -0.730  #>  3 disp  -633.   200.      NA   6721.   -47.1    108.    -96.1    -44.4    #>  4 hp    -321.   102.    6721.    NA    -16.5     44.2   -86.8    -25.0    #>  5 drat     2.20  -0.668  -47.1  -16.5   NA       -0.373   0.0871   0.119  #>  6 wt      -5.12   1.37   108.    44.2   -0.373   NA      -0.305   -0.274  #>  7 qsec     4.51  -1.89   -96.1  -86.8    0.0871  -0.305  NA        0.671  #>  8 vs       2.02  -0.730  -44.4  -25.0    0.119   -0.274   0.671   NA      #>  9 am       1.80  -0.466  -36.6   -8.32   0.190   -0.338  -0.205    0.0423 #> 10 gear     2.14  -0.649  -50.8   -6.36   0.276   -0.421  -0.280    0.0766 #> 11 carb    -5.36   1.52    79.1   83.0   -0.0784   0.676  -1.89    -0.464  #> # … with 3 more variables: am <dbl>, gear <dbl>, carb <dbl>  covary(mtcars) #> ℹ Applying `stats::cov` to each column pair #> # A tibble: 11 × 12 #>    term      mpg     cyl   disp      hp     drat      wt     qsec       vs #>    <chr>   <dbl>   <dbl>  <dbl>   <dbl>    <dbl>   <dbl>    <dbl>    <dbl> #>  1 mpg     NA     -9.17  -633.  -321.     2.20    -5.12    4.51     2.02   #>  2 cyl     -9.17  NA      200.   102.    -0.668    1.37   -1.89    -0.730  #>  3 disp  -633.   200.      NA   6721.   -47.1    108.    -96.1    -44.4    #>  4 hp    -321.   102.    6721.    NA    -16.5     44.2   -86.8    -25.0    #>  5 drat     2.20  -0.668  -47.1  -16.5   NA       -0.373   0.0871   0.119  #>  6 wt      -5.12   1.37   108.    44.2   -0.373   NA      -0.305   -0.274  #>  7 qsec     4.51  -1.89   -96.1  -86.8    0.0871  -0.305  NA        0.671  #>  8 vs       2.02  -0.730  -44.4  -25.0    0.119   -0.274   0.671   NA      #>  9 am       1.80  -0.466  -36.6   -8.32   0.190   -0.338  -0.205    0.0423 #> 10 gear     2.14  -0.649  -50.8   -6.36   0.276   -0.421  -0.280    0.0766 #> 11 carb    -5.36   1.52    79.1   83.0   -0.0784   0.676  -1.89    -0.464  #> # … with 3 more variables: am <dbl>, gear <dbl>, carb <dbl>"}]
