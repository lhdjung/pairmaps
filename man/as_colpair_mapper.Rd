% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/as_colpair_mapper.R
\name{as_colpair_mapper}
\alias{as_colpair_mapper}
\title{Adverb for new column-pair mapping functions}
\usage{
as_colpair_mapper(
  f,
  eval_f = TRUE,
  class = TRUE,
  default_diagonal = NA,
  default_quiet = FALSE,
  ...
)
}
\arguments{
\item{f}{A function that takes two or more arguments.}

\item{eval_f}{Boolean. If set to \code{FALSE}, \code{f} will appear in the output
function by name rather than as its body and arguments. Default is \code{TRUE}.
See details.}

\item{class}{Boolean. If \code{TRUE} (the default), the data frames returned by
the output function will inherit a class that starts on \code{"pairmaps_df_"},
followed by the name of \code{f}.}

\item{default_diagonal, default_quiet}{Defaults for the \code{.diagonal} and
\code{.quiet} arguments of the output function. By default of the \emph{present}
function, these will be \code{NA} and \code{FALSE}, respectively.}

\item{...}{These dots must be empty.}
}
\value{
A function. See \code{vary()} and \code{covary()} for examples of functions
made by \code{as_colpair_mapper()}.
}
\description{
\code{as_colpair_mapper()} takes a function \code{f} and returns a new
function that applies \code{f} to each pair of columns in a data frame.
}
\details{
Setting \code{eval_f} to \code{FALSE} can be helpful if you copy and paste the
resulting function into a script. In this case, it makes sense to refer to
one particular function by name, rather than copying and pasting a lengthy
function definition \emph{within} your new function definition, and manually
updating it when the mapped function changes.

However, this should only be considered if the value of \code{f} is completely
unambiguous, because such ambiguity might lead to a very subtle bug. See
\code{vignette("using-pairmaps")}, section \emph{Assignment and copying}.
}
\examples{
# From `?corrr::colpair_map()` -- a function that
# extracts the p-value from a t-test:
calc_p_value <- function(vec_a, vec_b) {
  stats::t.test(vec_a, vec_b)$p.value
}

# Derive a new mapping function:
p_value_map <- as_colpair_mapper(f = calc_p_value)

# Below are three near-equivalent calls.
# The only difference: In the first two cases,
# the output tibble inherits an extra class
# that includes the name of `f`. Here, it is
# `"pairmaps_df_calc_p_value"`.

# 1. Using a ready-made mapping function:
p_value_map(.data = mtcars)

# 2. Directly working with the adverb:
as_colpair_mapper(f = calc_p_value)(.data = mtcars)

# 3. Calling the underlying function:
corrr::colpair_map(.data = mtcars, .f = calc_p_value)

# (In the second call, R first evaluates
# `as_colpair_mapper(f = calc_p_value)` to a
# mapping function just like `p_value_map()`,
# and then calls that new function on `mtcars`.)
}
\references{
Wickham, H. (2019). \emph{Advanced R} (Second Edition), CRC
Press/Taylor and Francis Group. https://adv-r.hadley.nz/index.html.
}
\seealso{
\itemize{
\item This function is based on \code{corrr::colpair_map()}. For comparisons between
them, see \code{vignette("using-pairmaps")}.
\item The output function is constructed using \code{rlang::new_function()}.
\item For more information on adverbs / function factories like
\code{as_colpair_mapper()}, see Wickham (2019), ch. 10-11, and
\code{vignette("factory-labels")}.
}
}
